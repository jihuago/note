## B+树索引
> 数据页可以组成一个双向链表，而每个数据页中的记录会按照主键值从小到大的顺序组成一个单向链表，
> 每个数据页都会为存储在它里边的记录生成一个页目录，在通过主键查找某条记录的时候可以在页目录中使用二分法
> 快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。

### 没有索引的查找
#### 在一个页的查找
目前表中的记录比较少，所有的记录都可以被存放到一个页中，在查找记录的时候可以根据搜索条件的不同分为两种情况：
* 以主键为搜索条件
在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可
  
* 以非主键列作为搜索条件
这种情况只能从最小记录开始依次遍历单链表中的每条记录
  
#### 在很多页中查找
1. 定位到记录所在的页
2. 从所在的页内查找相应的记录
> 在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们并不能快速定位到记录所在的页， 
> 所以只能从第一个页沿着双向链表一直往下找，在每一个页根据上面所说的方法来查找指定的记录。

* 页分裂
> 为了保证下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。MySQL会通过一些诸如记录移动的操作
>来始终保证这个状态一直成立

* 给所有页建立一个目录项
由于数据页的编号可能并不是连续的，所以在向表插入许多记录后，页在物理存储上可能并不挨着，所以如果想从
  这么多页中根据主键值快速定位某些记录所在的页，需要给它们做个目录，每个页对应一个目录项，每个目录项
  包括下边两个部分：
  * 页的用户记录中最小的主键值，我们用key来表示
  * 页号，我们用page_no表示
    
![](../images/20210824154241.png)
以页28为例，它对应的目录项2，这个目录项中包含着该页的页号28以及该页中用户记录的最小主键值5.
我们只需哟把几个目录项在物理存储器上连续存储，比如把他们放到一个数组里，就可以实现根据主键值快速查找
某条记录了。
比方说我们想找主键值为20的记录，具体查找过程分两步：
1. 先从目录项中根据二分法快速确定出主键值为20的记录在目录项3，它的页是页9
2. 再根据在页中查找记录的方式去页9中定位具体的记录

目录项纪录中只存储主键值和对应的页号，比用户记录需要的存储空间小多了，但是不论怎么说一个页只有16KB大小，
能存放的目录项纪录也是有限的，那如果表中的数据太多，以至于一个数据页不足以存放所有的目录项纪录。就整多一个目录项纪录的页。

> 不论是存放用户记录的数据页，还是存放目录记录的数据页，都把他们存放到B+树这个数据结构中，也称这些数据页为节点。
> 实际用户记录其实都存放在B+树的最底层的节点上，这些节点被称为叶子节点，其余用来存放目录项的节点称为非叶子节点，其中B+树最上边的那个节点也称为根节点。

### 聚簇索引
B+树本身就是一个目录，或者说本身就是一个索引。它有两个特点：
1. 使用记录主键值的大小进行记录和页的排序
  * 页内的记录是按照主键的大小顺序排成一个单向链表
  * 各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表
  * 存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表
2. B+树的叶子节点存储的是完整的用户记录
  所谓完整的用户记录，就是指这个记录中存储了所有列的值
   
我们把具有这两种特性的B+树称为聚簇索引，所有完整的用户记录都存放在这个聚簇索引的叶子节点处。
这种聚簇索引并不需要我们在MySQL语句中显式的使用INDEX语句去参加，InnoDB存储引擎会自动的为我们创建聚簇索引。
### 二级索引
聚簇索引只能在搜索条件是主键值时才能发挥作用，因为B+树中的数据都是按照主键进行排序的。
如果以别的列作为搜索条件，需要多建几颗B+树，不同的B+树中的数据采用不同的排序规则。
#### 二级索引的特点
1. 使用记录C列的大小进行记录和页的排序
  * 页内的记录是按照C列的大小顺序排成一个单向链表
  * 各个存放用户记录的页也是根据页中记录的C列大小顺序排成一个双向链表
  * 存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的C列大小顺序排成一个双向链表
2. B+树的叶子节点存储的并不是完整的用户记录，而只是C列+主键这两个列的值
根据C列大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根据C2列的值查找完整的用户记录，需要到聚簇索引中再查一次，这个过程叫做回表。
   
#### 联合索引
我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比如让B+树按照C2和C3树列的大小进行排序，这个包含两层含义：
* 先把各个记录和页按照C2列进行排序
* 在记录的C2列相同的情况下，采用C3列进行排序
* B+树叶子节点处用户记录由C2、C3和主键C1列组成

注意：
以C2和C3列的大小为排序规则建立的B+树称为联合索引，本质上也是一个二级索引。它的意思与分别为C2和C3列分别建立索引的是不同的。不同点如下：
1. 建立联合索引只会建立1颗B+树
2. 为C2和C3列分别建立索引会分别以C2和C3列的大小为排序规则建立2棵B+树

### InnoDB的B+树索引的注意事项
#### B+树的形成过程
1. 每当为某个表创建一个B+树索引（聚簇索引不是人为创建，默认就有）的时候，都会为这个索引创建一个根节点页面。最开始表中没有数据的时候，每个B+树索引
对应的根节点中既没有用户记录，也没有目录项记录
   
2. 随后向表中插入用户记录时，先把用户记录存储到这个根节点中
3. 当根节点中的可用空间用完时继续插入记录，此时会将根节点中的所有记录复制到一个新分配的页，比如页a中，然后对这个新页进行页分裂的操作，得到另一个新页，
比如页b。这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值）的大小就会被分配到页a或页b，而根节点便升级为存储目录项记录的页
   
> 一个B+数索引的根节点自诞生之日起，便不会再移动。这样只要我们对某个表建立一个索引，那么它的根节点的页号便会被记录到某个地方，然后凡是InnoDB存储引擎
> 需要用到这个索引时，都会从那个固定的地方取出根节点的页号，从而来访问这个索引。

## B+树索引的使用
* 每个索引都对应一棵B+树，B+树分为好多层，最下边一层是叶子节点，其余的是内节点。所有用户记录都存储在B+树的叶子节点，所有目录项记录都存储在内节点
* InnoDB存储引擎会自动为主键建立聚簇索引，聚簇索引的叶子节点包含完整的用户记录
* 二级索引的叶子节点包含的用户记录由 `索引列+主键`组成，所以如果想通过二级索引来查找完整的用户记录，需要通过回表操作，也就是在通过二级索引
找到主键值之后再到聚簇索引中查找完整的用户记录
  
* B+树中每层结点都是按照索引列值从小到大的顺序排序而组成了双向链表，而且每个页内的记录都是按照索引列的值从小到大的顺序而形成一个单链表。
* 通过索引查找记录是从B+树的根节点开始，一层一层向下搜索，由于每个页面都按照索引列的值建立了Page Directory，所在在这些页面中的查找非常快

### B+树索引使用的条件
```html

CREATE TABLE person_info(
    id INT NOT NULL auto_increment,
    name VARCHAR(100) NOT NULL,
    birthday DATE NOT NULL,
    phone_number CHAR(11) NOT NULL,
    country varchar(100) NOT NULL,
    PRIMARY KEY (id),
    KEY idx_name_birthday_phone_number (name, birthday, phone_number)
);
```
#### 全值匹配
如果我们的搜索条件中的列和索引列一致的话，这种情况就称为全值匹配。
> SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday = '1990-09-27' AND phone_number = '15123983239';

因为MySQL有查询优化器会分析搜索条件并且按照可以使用的索引中列的顺序来决定先使用哪个搜索条件，所以WHERE子句中的搜索条件的顺序对查询结果没有影响。

#### 匹配左边的列
搜索语句中可以不同包含全部联合索引中的列，只包含左边的的就行。
* 为什么搜索条件中必须出现左边的列才可以使用到这个B+树索引
因为B+树的数据页和记录先是按照左侧的列的值排序的，在左侧列的值相同的情况下才使用下一列进行排序。直接跳过左侧列直接查找可能是无序的。
  
#### 匹配列前缀
字符串排序的本质就是比较哪个字符串大一点，哪个字符串小一点。一般的比较规则都是逐个比较字符的大小。
* 先比较字符串的第一个字符，第一个字符小的那个字符串就比较小。
* 如果两个字符串的第一个字符相同，那就再比较第二个字符，第二个字符比较小的那个字符串就比较小。
* 如果两个字符串的第二个字符也相同，那就接着比较第三个字符，依此类推。
也就是说这些字符串的前n个字符，也就是前缀都是排好序的，所以对于字符串类型的索引列来说，我们只匹配它的前缀也是可以快速定位记录的，
  比如`LIKE As%`
  
> 有时候有一些匹配某些字符串后缀的需求，比如某个表中有一个url列
```html
url
www.baidu.com
www.jd.com
www.gov.cn
```
为了在查询时用到这个索引而不至于全表扫描，可以把后缀查询改写成前缀查询：把表中的数据全部逆序存储
```html
url
moc.udiab.www
....
```
这样再查找以com为后缀的网址时搜索条件便可以这么写：WHERE url LIKE 'moc%'，这样就可以用到索引了。

#### 匹配范围值
* 使用联合索引进行范围查找，如果对多个列同时进行范围查找，只有对索引最左边的那个列进行范围查找的时候才能用到B+索引
> 因为只有最左列相同的情况下才能用下一列进行排序，而如果最左列进行范围排序，下一列并不是有序的

#### 精确匹配某一列并范围匹配另外一列
对于同一个联合索引来说，虽然对多个列都进行范围查找时只能用到最左边的那个索引列，但是如果左边的列是精确查找，则右边的列可以进行范围查找。

### 索引用于排序的情况
* order by 子句用到了索引列且按照索引列的顺序给出，就可以用到索引
* 用于分组，分顺序需要和B+树中索引列的顺序是一致的
> GROUP BY name,birthday
index(name, birthday)

### 不可以使用索引进行排序的几种情况
* ASC、DESC混用
* 排序列包含非同一个索引的列
> 有时候用来排序的多个列不是一个索引里的，这种情况也不能使用索引进行排序，比方说：
> SELECT * FROM person_info ORDER BY name, country LIMIT 10;

* 排序列使用了复杂的表达式
要想使用索引进行排序操作，必须保证索引列是以单独列的形式出现，而不是修饰过的形式，如：
> SELECT * FROM person_info ORDER BY UPPER(name) LIMIT 10;

## 回表的代价
## 覆盖索引
最好在查询列表里只包含索引列，比如这样：
> SELECT name, birthday, phone_number FROM person_info WHERE name > 'Asa' AND name < 'Barlow'

因为我们只查询name, birthday, phone_number这三个索引列的值，所在在通过idx_name_birthday_phone_number索引得到结果后就不必到聚簇索引中再查找记录
的剩余列。这样就省去了回表操作带来的性能损耗。
我们把这种只需要用到索引的查询方式称为`索引覆盖`

## 如何挑选索引
* 只为用于搜索、排序或分组的列创建索引
> 也就是说，只为出现在WHERE子句中的列，链接子句中的链接列，或者出现在ORDER BY或GROUP BY子句中的列创建索引

* 考虑列的基数
列的基数指的是某一列中不重复数据的个数，在记录行数一定的情况下，列的基数越大，该列中的值越分散，列的基数越小，该列中的值越集中。
最好为那些列的基数大的列建立索引。
  
* 索引列的类型尽量小
  * 数据类型越小，在查询时进行的比较操作越快
  * 数据类型越小，索引占用的存储空间越少，在一个数据页内就可以放下更多的记录，从而减少磁盘I/O带来的性能损耗

## 主键插入顺序
* 对于一个使用InnoDB存储引擎的表来说，在没有显式的创建索引时，表中的数据实际上都是存储在聚簇索引的叶子节点的。
* 而记录又是存储在数据页中的，数据页和记录又是按照记录主键值从小到大的顺序进行排序，所以如果我们插入的记录的主键值是依次增大的，我们每插满一个数据页
就换到下一个数据页继续插。
  
# 总结
1. B+树索引在空间和时间上都有代价
2. B+树索引适用于下面情况
* 全值匹配
* 匹配左边的列
* 匹配范围值
* 精确匹配某一列并范围匹配另外一列
* 用于排序
* 用于分组

3. 在使用索引时需要注意下面事项
* 只为用于搜索、排序或分组的列创建索引
* 为列的基数大的列创建索引
* 索引列的类型尽量小
* 可以只对字符串值的前缀建立索引
* 只有索引列在比较表达式中单独出现才可以使用索引
* 为了尽可能少的让聚簇索引发生页面分裂和记录移位的情况，建议让主键拥有AUTO_INCREMENT属性
* 尽量使用覆盖索引进行查询，避免回表带来的性能损耗