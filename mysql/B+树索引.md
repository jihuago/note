## B+树索引
> 数据页可以组成一个双向链表，而每个数据页中的记录会按照主键值从小到大的顺序组成一个单向链表，
> 每个数据页都会为存储在它里边的记录生成一个页目录，在通过主键查找某条记录的时候可以在页目录中使用二分法
> 快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。

### 没有索引的查找
#### 在一个页的查找
目前表中的记录比较少，所有的记录都可以被存放到一个页中，在查找记录的时候可以根据搜索条件的不同分为两种情况：
* 以主键为搜索条件
在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可
  
* 以非主键列作为搜索条件
这种情况只能从最小记录开始依次遍历单链表中的每条记录
  
#### 在很多页中查找
1. 定位到记录所在的页
2. 从所在的页内查找相应的记录
> 在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们并不能快速定位到记录所在的页， 
> 所以只能从第一个页沿着双向链表一直往下找，在每一个页根据上面所说的方法来查找指定的记录。

* 页分裂
> 为了保证下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。MySQL会通过一些诸如记录移动的操作
>来始终保证这个状态一直成立

* 给所有页建立一个目录项
由于数据页的编号可能并不是连续的，所以在向表插入许多记录后，页在物理存储上可能并不挨着，所以如果想从
  这么多页中根据主键值快速定位某些记录所在的页，需要给它们做个目录，每个页对应一个目录项，每个目录项
  包括下边两个部分：
  * 页的用户记录中最小的主键值，我们用key来表示
  * 页号，我们用page_no表示
    
![](../images/20210824154241.png)
以页28为例，它对应的目录项2，这个目录项中包含着该页的页号28以及该页中用户记录的最小主键值5.
我们只需哟把几个目录项在物理存储器上连续存储，比如把他们放到一个数组里，就可以实现根据主键值快速查找
某条记录了。
比方说我们想找主键值为20的记录，具体查找过程分两步：
1. 先从目录项中根据二分法快速确定出主键值为20的记录在目录项3，它的页是页9
2. 再根据在页中查找记录的方式去页9中定位具体的记录

目录项纪录中只存储主键值和对应的页号，比用户记录需要的存储空间小多了，但是不论怎么说一个页只有16KB大小，
能存放的目录项纪录也是有限的，那如果表中的数据太多，以至于一个数据页不足以存放所有的目录项纪录。就整多一个 目录项纪录的页。

> 不论是存放用户记录的数据页，还是存放目录记录的数据页，都把他们存放到B+树这个数据结构中，也称这些数据页为节点。
> 实际用户记录其实都存放在B+树的最底层的节点上，这些节点被称为叶子节点，其余用来存放目录项的节点称为非叶子节点，其中B+树最上边的那个节点也称为根节点。

### 聚簇索引
B+树本身就是一个目录，或者说本身就是一个索引。它有两个特点：
1. 使用记录主键值的大小进行记录和页的排序
  * 页内的记录是按照主键的大小顺序排成一个单向链表
  * 各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表
  * 存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表
2. B+树的叶子节点存储的是完整的用户记录
  所谓完整的用户记录，就是指这个记录中存储了所有列的值
   
我们把具有这两种特性的B+树称为聚簇索引，所有完整的用户记录都存放在这个聚簇索引的叶子节点处。
这种聚簇索引并不需要我们在MySQL语句中显式的使用INDEX语句去参加，InnoDB存储引擎会自动的为我们创建聚簇索引。
### 二级索引
聚簇索引只能在搜索条件是主键值时才能发挥作用，因为B+树中的数据都是按照主键进行排序的。
如果以别的列作为搜索条件，需要多建几颗B+树，不同的B+树中的数据采用不同的排序规则。
#### 二级索引的特点
1. 使用记录C列的大小进行记录和页的排序
  * 页内的记录是按照C列的大小顺序排成一个单向链表
  * 各个存放用户记录的页也是根据页中记录的C列大小顺序排成一个双向链表
  * 存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的C列大小顺序排成一个双向链表
2. B+树的叶子节点存储的并不是完整的用户记录，而只是C列+主键这两个列的值
根据C列大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根据C2列的值查找完整的用户记录，需要到聚簇索引中再查一次，这个过程叫做回表。
   
#### 联合索引
我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比如让B+树按照C2和C3树列的大小进行排序，这个包含两层含义：
* 先把各个记录和页按照C2列进行排序
* 在记录的C2列相同的情况下，采用C3列进行排序
* B+树叶子节点处用户记录由C2、C3和主键C1列组成

注意：
以C2和C3列的大小为排序规则建立的B+树称为联合索引，本质上也是一个二级索引。它的意思与分别为C2和C3列分别建立索引的是不同的。不同点如下：
1. 建立联合索引只会建立1颗B+树
2. 为C2和C3列分别建立索引会分别以C2和C3列的大小为排序规则建立2棵B+树

### InnoDB的B+树索引的注意事项
#### B+树的形成过程
1. 每当为某个表创建一个B+树索引（聚簇索引不是人为创建，默认就有）的时候，都会为这个索引创建一个根节点页面。最开始表中没有数据的时候，每个B+树索引
对应的根节点中既没有用户记录，也没有目录项记录
   
2. 随后向表中插入用户记录时，先把用户记录存储到这个根节点中
3. 当根节点中的可用空间用完时继续插入记录，此时会将根节点中的所有记录复制到一个新分配的页，比如页a中，然后对这个新页进行页分裂的操作，得到另一个新页，
比如页b。这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值）的大小就会被分配到页a或页b，而根节点便升级为存储目录项记录的页
   
> 一个B+数索引的根节点自诞生之日起，便不会再移动。这样只要我们对某个表建立一个索引，那么它的根节点的页号便会被记录到某个地方，然后凡是InnoDB存储引擎
> 需要用到这个索引时，都会从那个固定的地方取出根节点的页号，从而来访问这个索引。
