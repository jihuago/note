## 缓存的重要性
对于使用InnoDB作为存储引擎的表来说，不管是用于存储用户数据的索引（包括聚簇索引和二级索引），还是各种系统数据，都是以页的形式存放在表空间中的，
而所谓的表空间只不过是InnoDB对文件系统上一个或几个实际文件的抽象，也就是说我们的数据到底还是存储在磁盘上的。

> InnoDB存储引擎在处理客户端的请求时，当需要访问某个页的数据时，就会把完整的页的数据全部加载到内存中。
> 将整个页加载到内存中后就可以进行读写访问了，而后将其缓存起来，这样将来有请求再次访问该页，就可以省去磁盘IO的开销了

### InnoDB的Buffer Pool
InnoDB为了缓存磁盘中的页，在MySQL服务器启动的时候就向操作系统申请了一片连续的内存，叫做Buffer Pool（缓冲池）。
默认情况下Buffer Pool只有128M，最小值为5M。通过配置innodb_buffer_pool_size参数的值
> [server]
> innodb_buffer_pool_size = 268435456

> 268435456的单位是字节

### free链表的管理
当我们最初启动MySQL服务器的时候，需要完成对Buffer Pool的初始化过程，就是先向操作系统申请Buffer Pool的内存空间，然后把它划分成若干对控制块和缓存页。

但是此时并没有真实的磁盘页被缓存到Buffer Pool中，之后随着程序的运行，会不断的有磁盘上的页被缓存到Buffer Pool中。
把所有空闲的缓存页对应的控制块作为一个节点放到一个链表中，这个链表也可以被称作free链表。

### 缓存页的哈希处理
当我们需要访问某个页中的数据时，就会把该页从磁盘加载到Buffer Pool中。
* 如何知道该页在不在Buffer Pool中
我们是根据表空间号 + 页号来定位一个页的，也就相当于表空间号 + 页号是一个key，缓存页就是对应的value。所以通过哈希表来快速定位。
  
所以可以用**表空间号+页号**作为Key，缓存页作为value创建一个哈希表，在需要访问某个页的数据时，先从哈希表中根据**表空间号+页号**看看有没有对应的缓存页，
如果有，直接使用该缓存页就好，如果没有，那就从free链表中选一个空闲的缓存页，然后把磁盘中对应的页加载到该缓存页的位置。

### flush链表的管理
如果我们修改了Buffer Pool中某个缓存页的数据，那它就和磁盘上的页不一致了，这样的缓存页也被称为脏页(dirty page)。但每次修改缓存页后，MySQL并不会
立即把修改同步到磁盘上，而是在未来的某个时间点进行同步。

* 如何知道Buffer Pool哪些是脏页
创建一个存储脏页的链表，凡是修改过的缓存页对应的控制块都会作为节点加入到一个链表中，因为这个链表节点对应的缓存页都是需要被刷新到磁盘上的，所以也叫flush链表。
  
### LRU链表的管理
* 缓存不够怎么办

Buffer Pool对应的内存大小毕竟是有限的，如果需要缓存的页占用的内存大小超过了Buffer Pool大小，也就是free链表中已经没有多余的空闲缓存页。解决方法是
把某些旧的缓存页从Buffer Pool中移除，然后再把新的页放进来。

* 移除那些缓存页

假设一共访问了n次页，那么被访问的页已经在缓存中的次数除以n就是所谓的缓存命中率，我们的期望就是让 缓存命中率越高越好。

简单的LRU链表：管理Buffer Pool的缓存页其实也是这个道理，当Buffer Pool中不再有空闲的缓存页时，就需要淘汰掉部分最近很少使用的缓存页。
通过创建一个链表，由于这个链表是为了按照最近最少使用的原则去淘汰缓存页的，所以这个链表可以被称为LRU链表。当我们需要访问某个页时，可以这样处理LRU链表：
    * 如果该页不在Buffer Pool中，在把该页从磁盘加载到Buffer Pool中的缓存页时，就把该缓存页对应的控制块作为节点塞到链表的头部
    * 如果该页已经缓存在Buffer Pool中，则直接把该页对应的控制块移动到LRU链表的头部

也就是说：只要我们使用到某个缓存页，就把该缓存页调整到LRU链表的头部，这样LRU链表尾部就是最近最少使用的缓存页。

所以当Buffer Pool的空闲缓存页使用完时，到LRU链表的尾部找些缓存页淘汰即可。

#### 划分区域的LRU链表

加载Buffer Pool的两种情况：
* 加载到Buffer Pool中的页不一定被用到
* 如果非常多的使用频率偏低的页被同时加载到Buffer Pool时，可能会把那些使用频率非常高的页从Buffer Pool中淘汰掉

因为有以上两种情况的存在，所以InnoDB把这个LRU链表按照一定比例分为两截，分别是：
* 一部分存储使用频率非常高的缓存页，所以这一部分链表也叫做热数据，或者称 young区域
* 另一部分存储使用频率不是很高的缓存页，所以这一部分链表也叫冷数据，或者叫old区域
