## 代码设计的定义

从底层上看：设计是定义系统组成并组织各组件间关系的过程。

另外一个角度看：类和对象的定义与配置。

* 系统的参与者

面向对象的系统由一系列类组成。决定系统中这些类的角色是非常重要的，而类由方法组成，所以在定义类时，必须决定哪些方法应该放在一起。

## 面向对象设计和过程式编程

* 两者的不同

两者的不同不在于：面向对象编程中包含对象。因为过程式也可以使用对象。类的出现并不鞥说明使用了面向对象设计。

* 面向对象和过程式编程的一个核心区别是如何分配职责

过程式编程表现为一系列命令和方法的连续调用。控制代码根据不同的条件执行不同的职责。这种自顶向下的控制方式导致了重复和相互依赖的代码遍布整个项目。

面向对象编程则将职责从客户端代码中移到专门的对象中，尽量减少相互依赖。

* 具体实例

为了说明以上几点，分别用面向对象和过程式代码的方式来分析一个简单的问题。假设我们要创建一个用于读写配置文件的工具。 为了重点关注代码的结构，示例中将忽略具体的功能实现。

* 过程式方式来解决这个问题

首先，用下面的格式来读写文本：

key:value

只需要两个函数：

		function readParams($sourceFile) {
			$params = array();

			//从$sourceFile中读取文本参数
			return $params;
		}

		function writeParams($params, $sourceFile) {
			//写入文本参数到$sourceFile
		}

readParams()函数的参数为源文件的名称。该函数试图打开文件，读取每一行内容并查找键/值对，然后用键/值对构建一个关联数组。最后，该函数给控制代码返回数组。

writeParams()以关联数组和指向源文件的路径作为参数，它循环遍历关联数组，将每对键/值写入文件。

下面是使用这两个函数的客户端代码：

	$file = './param.txt';
	$arr['key1'] = 'val1';
	$arr['key2'] = 'val2';

	writeParams($arr, $file);//将数组写到文件

	$output = readParams($file);//从文件读取数组


现在，我们被告知这个工具需要支持如下所示的XML格式：

	<params>
		<param>
			<key>my key</key>
			<val>my val</val>
		</param>
	</params>


如果参数文件以.xml结尾，就应该以XML模式读取参数文件。虽然这并不难调节，但可能会使我们的代码更能维护。这时，我们有两个选择：可以在控制代码检查文件扩展名。或者在读写函数中检测。采用后面哪种方法：

	function readParams($source) {
		$params = array();
		
		if (preg_match('/\.xml$/i', $source)) {
			//从$source中读取XML参数
		} else {
			//从$source中读取文本参数
		}

		return $params;
	}


	function writeParams($params, $source) {
		if (preg_match('/\.xml$/i', $source)) {
			//写入XML参数到$source
		} else {
			//写入文本参数到$source
		}
	}

如上所示，我们在两个函数中都要检测XML扩展名，这样的重复性代码会产生问题。

如果我们还被要求支持其他格式的参数，就要始终保持readParams()和writeParams()函数的一致性。

下面我们用类来处理相同的问题。首先，创建一个抽象的基类来定义类型接口：

	abstract class ParamHandler 
	{
		protected $source;
		protected $params = array();

		public function __construct($source) 
		{
			$this->source = $source;
		}

		public function addParam($key, $val)
		{
			$this->params[$key] = $val;
		}

		public function getAllParams()
		{
			return $this->params;
		}

		public static function getInstance($filename)
		{
			if (preg_match('/\.xml$/i', $filename)) {
				return new XmlParamHandler($filename)
			}
			return new TextParamHandler($filename)
		}
	
		abstract public function write();

		abstract public function read();
	}

我们创建了静态的getInstance()方法来检测文件扩展名，并根据文件扩展名返回特定的子类实例。

现在，我们定义多个子类。

	class TextParamHandler extends ParamHandler
	{

		public function write()
		{
			//写入文本文件
			//使用$this->params
		}

		public function read()
		{
			//读取文本文件内容
			//并复制给$this->params
		}
	
	}

当需要新增一个类型，我们只要修改父类中的getInstance()方法即可，然后增加多一个子类。

客户端代码将完全自动地根据文件扩展名来写入数据到文本或XML格式的文件：

	$test = ParamHandler::getInstance('./params.xml');

	$test->addParam('key1', 'val1');
	$test->addParam('key2', 'val2');

	$test->write();//写入xml格式中

### 职责

上面的例子中，在过程式中，控制代码的职责是判断文件格式，它判断了两次而不是一次。条件被绑定到函数中，但这仅是将判断的流程隐藏起来。

在面向对象代码中，我们在静态方法getInstance()中进行文件格式的选择，并且仅在getInstance()中检测文件扩展名一次，就可以决定使用哪一个合适的子类。	

客户端代码并不负责实现读写功能，它不需要知道自己属于哪个子类就可以使用给定的对象。

过程式代码忙于处理细节，而面向对象代码只需一个接口即可工作，并且不用考虑实现的细节。

## 内聚

内聚是一个模块内部各成分之间相关程度的度量。理想情况下，你应该使各组件职责清晰、分工明确。

如果代码间的关联范围太广，维护就会很困难---因为你需要在修改某部分代码的同时修改相关代码。

前面的ParamHandler类将相关的处理过程集中起来。用于处理XML的类方法间可以共享数据。因此，ParamHandler类是高度内聚的。

另一方面，过程式的例子则把相关的过程分离开，导致处理XML的代码在多个函数中同时出现。