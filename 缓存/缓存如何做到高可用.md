## 分布式缓存的高可用方案

从客户端方案、中间代理层方案和服务端方案考虑。

* 客户端方案

  在客户端配置多个缓存的节点，通过缓存写入和读取算法策略来实现分布式，从而提高缓存的可用性

* 中间代理层方案

  在应用代码和缓存节点之间增加代理层，客户端所有的写入和读取的请求都通过代理层，而代理层中会内置高可用策略，帮助提升缓存系统的高可用

* 服务端方案

  就是Redis2.4版本后提出的Redis Sentinel方案

### 客户端方案

关注缓存的写和读两个方面：

* 写入数据时，需要把被写入缓存的数据分散到多个节点中，即进行数据分片
* 读数据时，可以利用多组的缓存来做容错，提升缓存系统的可用性。关于读数据，可以使用主从和多副本两种策略。

#### 缓存数据如何分片

单一的缓存节点受到机器内存、网卡带宽和单节点请求量的限制，不能承担比较高的并发，因此考虑将数据分片，依照分片算法将数据打散到多个不同的节点上，每个节点上存储部分数据。

* 分片算法

  常见就是Hash分片算法和一致性Hash分片算法

  * Hash分片算法

    Hash分片算法就是对缓存的key做哈希计算，然后对总的缓存节点个数取余。

    * 优点

      简单易理解

    * 缺点

      当增加或减少缓存节点时，缓存总的节点个数变化造成计算出来的节点发生变化，从而造成缓存失效不可用

    如果采用Hash分片算法，最好建立在对于这组缓存命中率下降不敏感，比如下面还有另外一层缓存来兜底的情况。

* 一致性Hash算法

  一致性Hash算法可以很好解决增加和删减节点时，命中率下降的问题。

  * 缺点

    * 缓存节点在圆环上分布不平均，会造成部分缓存节点的压力较大；当某个节点故障时，这个节点所要承担的所有访问都会被顺移到另一个节点上，对后面节点造成压力

    解决方案：在一致性Hash算法中引入虚拟节点概念

    * 一致性Hash算法的脏数据问题

      解决方案：在使用一致性Hash算法时一定要设置缓存的过期时间，这样当发生漂移时，之前存储的脏数据可能已经过期，就可以减少存在脏数据的几率

  一致性Hash算法的节点数过多也会增加出问题的概率，因此推荐4-6个节点比较好。

#### Memcached的主从机制
Memcached不支持主从的部署方式。但可以在客户端来实现：为每一组Master配置一组Slave，更新数据时主从同步更新。
读取时，优先从Slave中读数据，如果读取不到数据就穿透到Master读取，并且将数据回种到Slave保持Slave数据的热度。

### 中间代理层方案
虽然客户端已经能实现大部分的问题，但是只能在单一语言系统之间复用。例如微博使用Java语言实现了一套逻辑，使用PHP就难以复用，需要
重新写一套。而中间代理层的方案就是为了解决这个问题。
有很多中间代理层的方案：比如Mcrouter、https://github.com/CodisLabs/codis

### 服务端方案
Redis Sentinel模式来解决主从Redis部署时的高可用问题，它可以在主节点挂了后自动将从节点提升为主节点，保证整体集群的可用性。
