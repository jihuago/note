package main

import (
	"fmt"
	"time"
)

/*
	协程goroutime与通道channel

	## 并发、并行和协程
	* 什么是协程
		* 一个应用程序是运行在机器上的一个进程
		* 进程是一个运行在自己内存地址空间里的独立执行体
		* 一个进程由一个或多个操作系统线程组成，这些线程其实是共享同一个内存地址空间的一起工作的执行体
		* 几乎所有程序都是多线程的，以便让用户或计算机不必等待，或者能够同时服务多个请求（如Web服务器），或增加性能和吞吐量
		* 一个并发程序可以在一个处理器或者内核上使用多个线程来执行任务，但是只有同一个程序在某个时间点同时运行在多核或者多处理器上才是真正的并行
		* 并行是一种通过使用多处理器以提高速度的能力。所以并发程序可以并行的，也可以不是
		* 公认的，使用多线程的应用难以做到准确，最主要的问题是内存中的数据共享，它们会被多线程以无法预知的方式进行操作，
			导致一些无法重现或随机的结果（称为竞态）
		*不要使用全局变量或共享内存，它们会给你的代码在并发运算的时候带来危险
	* 解决之道
		* 同步不同的线程，对数据加锁，这样同时就只有一个线程可以变更数据。在Go标准库sync有一些工具用来在低级别的代码中实现加锁；
		但sync不再适合现代多核/多处理器编程，且更容易让代码出错以及更低的性能

		* 在GO中，应用程序并发处理的部分被称作goroutines(协程)，它可以进行更有效的并发运算。
		* 协程和操作系统线程之间并无一对一的关系：协程是根据一个或多个线程的可用性，映射（多路复用，执行于）在他们之上的
		* 协程工作在相同的地址空间中，所以共享内存的方式一定是同步的，Go使用channels来同步协程
		* 当系统调用阻塞协程时，其他协程会继续在其他线程上工作。协程的设计隐藏了许多线程创建和管理方面的复杂工作
		* 协程是轻量的，比线程更轻。协程使用少量的内存和资源：使用4K的栈内存就可以在堆中创建它们。因为创建非常廉价，
			必要的时候可以轻松创建并运行大量的协程。
		* 协程可以运行在多个操作系统线程之间，也可以运行在线程之内，让你可以很小的内存占用就可以处理大量的任务
		* 存在两种并发方式：确定性和非确定性的（加锁）
	* 协程的栈会根据需要进行伸缩，不出现栈溢出；开发者不需要关心栈的大小。当协程结束的时候，它会静默退出：用来启动这个协程的函数不会得到任何的返回值
	* 协程是通过使用关键字go 调用一个函数或者方法来实现的（也可以是匿名或lambda函数）
	* 在一个协程中，比如它需要进行非常密集的运算，可以在运算循环中周期的使用runtime.Gosched()：这会让出处理器，允许运行其他协程；
		它并不会使当前协程挂起，所以它会自动恢复执行。使用Gosched()可以使计算均匀分布，使通信不至于迟迟得不到响应

	* 协程一个有用的例子：在一个非常长的数组中查找一个元素
		将数组分割为若干不重复的切片，然后给每一个切片启动一个协程进行查找计算。这样许多并行的协程可以用来进行查找任务，整体的查找时间会缩短。

	* Go协程与协程
		GO协程意味着并行，协程一般来说不是这样的
		Go协程通过通道来通信；协程通过让出和恢复操作来通信

*/
func main() {
	fmt.Println("In main()")
	go longWait()
	go shortWait()
	fmt.Println("About to sleep in main()")

	// 让main()函数暂停10秒从而确定它会在另外两个协程之后结束，如果不这样，main()会提前结束，longWait()无法完成
	time.Sleep(5 * 1e9)

	// 当main()函数返回的时候，程序退出：它不会等待任何其他非main协程的结束。
	// 另外，协程是独立的处理单元，一旦陆续启动一些协程，你无法确定他们是什么时候真正开始执行的。你的代码逻辑必须
	fmt.Println("At the end of main()")
}

func longWait() {
	fmt.Println("begining logWait()")
	time.Sleep(5 * 1e9)
	fmt.Println("End od long Wait")
}

func shortWait()  {
	fmt.Println("Beginning shortWait()")
	time.Sleep(2 * 1e9)
	fmt.Println("End of shortWait()")
}