package main

import "fmt"

func main() {
	// 切片是基于数组实现的，它的底层是数组，本身非常小。因为基于数组实现，所以切片的底层的内存是连续分配的，效率非常高。
	// 切片对象非常小，是因为它只有3个字段的数据结构：一个是指向底层数组的指针，一个是切片的长度，一个是切片的容量。

	// 声明和初始化
	slice := make([]int, 5) // 声明一个切片，容量是5，容量对应的是切片底层数组
	fmt.Println(slice)

	// 使用字面量方式创建切片
	s2 := []int{1, 2}
	fmt.Println(s2)

	slice = make([]int, 5, 10);// 切片长度是5，容量是10  容量必须 >= 长度
	fmt.Println(cap(slice)) // cap() 求容量
	fmt.Println(len(slice))

	// nil切片
	//var nilSlice []int // nil切片意味着指向底层数组的指针为nil

	// 空切片
	//slice1 := []int{} // 空切片表示一个空集合，空切片对应的指针是个地址


	// 将切片追加到另一个切片
	// newSlice = append(newSlice, slice...) // 通过...操作符，把一个切片追加到另一个切片

	// 切片的扩容策略
	/*
		首先判断，如果新申请容量大于2倍的旧容量，最终容量=新申请容量
		否则判断，如果旧切片的长度<1024，则最终容量就是旧容量的两倍
		否则判断，如果旧切片长度>=1024，则最终容量从旧容量开始循环增加原来的1/4，直到最终容量>新申请的容量
	 */

	s := []int{}
	//var s []int
	// 判断切片是否为空 len(s) == 0
	if len(s) != 0 {
		fmt.Println("s切片为非空")
	}

}
