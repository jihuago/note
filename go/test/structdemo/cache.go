package main

import (
	"fmt"
	"unsafe"
)

type S struct {
	B byte
	I32 int32
	I64 int64
}

func main() {
	// 内存对齐：对齐规则是按照成员的声明顺序，依次安排内存，其偏移量是为成员大小的整数倍
	// 内存对齐： 内存是按照成员的声明顺序，依次分配，第一个成员偏移量是0，其余每个成员的偏移量为指定数的整数倍数。像这样进行内存的分配叫做内存对齐。
	// 为什么需要内存对齐：1. 并不是所有硬件平台都能访问任意地址上的任意数据 2. 性能原因， 访问未对齐的内存，处理器需要做两次内存访问，而对齐的内存只
	// 需要访问一次
	s := S{}

	// 内存对齐的规则：
	// 1. 对于具体类型来说，对齐值 = min(编译器默认对齐值, 类型大小Sizeof长度) 也就是在默认设置的对齐值和类型的内存占用大小之间，取最小值为该类型的对齐值。
	// 2. struct 在每个字段都内存对齐之后，其本身也要进行对齐，对齐值=min(默认对齐值, 字段最大类型长度) struct的所有字段中，最大的那个类型长度以及默认对齐值之间
	// 取最小的那个

	fmt.Printf("s size :%v, s.B地址", unsafe.Sizeof(s))

	// 结构体占用内存过大的问题： 根据计算对齐值进行成员顺序的拼凑，可以一定程度上缩小结构体占用的内存
	// 1. 内存对齐影响struct的大小
	// 2. struct的字段顺序影响struct的大小


}
