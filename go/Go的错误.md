## 处理错误的基本策略
* 哨兵错误
    哨兵错误的处理方式通过特定值表示成功和不同错误，依靠调用方对错误进行检查：
  ```html
        if err === Errsomething {...}
```
例如，io.EOF = errors.New("EOF")
这种错误处理的方式引入了上下层代码的依赖，如果被调用方的错误类型发生了变化，则调用方也需要对代码进行修改

* 隐式错误
> if err != nil {return err}

这种错误处理的方式直接返回错误的任何细节，直接将错误进一步报告给上层。这种情况下，错误在当前调用方这里完全没有进行任何加工，与没有进行处理几乎是等价的
这回产生一个致命的问题在于：丢失调用的上下文信息，如果某个错误连续向上层传播了多次，那么上层代码可能在输出某个错误时，根本无法判断该错误的错误信息从
哪儿传播出来。