## 散列表
散列表用的是数组支持按照下标随机访问数据的特征，所以散列表其实就是数组的一种扩展，由数组演化而来。
## 散列冲突
再好的散列函数也无法避免散列冲突。常用的散列冲突解决方法有两类，开放寻址放和链表法
1. 开放寻址法
开放寻址法的核心思想是，如果出现了散列冲突，就重新探测一个空闲未知，将其插入。

* 如何探测新的位置
线性探测、二次探测、双重散列

* 装载因子
不管用哪种探测方法，当散列表中空闲位置不多时，散列冲突的概率就会大大提高。为了尽可能保证散列表的操作效率，一般情况下，为了保证散列表
有一定比例的空闲槽位。用装载因子来表示空位的多少。
```
散列表的装载因子=填入表中的元素个数/散列表的长度
```
2. 链表法
链表法是一种更加常用的散列冲突解决方法。在散列表中，每个桶bucket会对应一条链表，所有散列值相同的元素都放到相同桶对应的链表中。

### 散列表查询效率
散列表的查询效率不能笼统说成是O(1)，与散列函数、装载因子、散列冲突等都有关系。如果散列函数设计不好，或者装载因子过高，都可能导致散列
冲突发生的概率升高，查询效率下降。
在极端情况下，有些恶意的攻击者，还有可能通过精心构造的数据，使得所有的数据经过散列函数之后，都散列到同一个槽里。
如果使用的是基于链表的冲突解决方法，那这个时候，散列表就会退化为链表，查询的时间复杂度就从O(1)退化成O(n)
#### 如何设计散列函数

