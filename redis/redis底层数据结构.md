### Redis快的原因
1. redis是内存数据库，所有操作都在内存上完成
2. 因为redis的高效数据结构，高效数据结构是Redis快速处理数据的基础
### 底层数据结构
* 简单动态字符串
* 双向链表
* 压缩链表
* 哈希表
* 跳表
* 整数数组

![](../images/redis-img.jpg)

### 键和值用什么结构组织
#### 全局哈希表
* 为了实现从键到值的快速访问，Redis使用了一个哈希表来保存所有键值对。
* 一个哈希表，其实就是一个数组，数组的每个元素称为一个哈希桶子
* 哈希桶中的元素保存的并不是值本身，而是指向具体值的指针。
不管值是string，还是集合类型，哈希桶中的元素都是指向它们的指针。

![](../images/hashtable.jpg)

哈希桶中的entry元素保存了`*key`和`*value`指针，分别指向了实际的键和值，这样一来，即使
值是一个集合，也可以通过`*value`指针被查找到。

### 哈希表的冲突问题和rehash带来的操作阻塞
* 当往哈希表写入更多数据，哈希冲突是不可避免的问题。也就是两个key的哈希值和哈希桶计算关系时，正好落到了同一个哈希桶上。
* Redis解决哈希冲突的方法是链式哈希。就是同一个哈希桶中的多个元素用一个链表来保存，他们之间用指针链接。
* 如果哈希表写入的数据越来也多，哈希冲突可能也会越拉越多，这就会导致某些哈希冲突链过长，导致这链上的元素查找耗时长。
* 为了解决上面这个问题，Redis会对哈希表做rehash操作。rehash就是增加现有的哈希桶数量，让逐渐增多的entry元素能在更多桶之间分散保存，减少单个桶中的元素数量

### 集合数据操作效率
#### 有哪些底层数据结构
集合类型的底层数据结构主要有5种：整数数组、双向链表、哈希表、压缩列表和跳表。

* 跳表在链表的基础上，增加了多级索引，通过索引位置的几个跳转，实现数据的快速定位。

![](../images/jump-table.jpg)

#### 不同操作的复杂度
复杂度的高度是我们选择集合类型（List/Hash/Set/Sorted Set）的重要依据。通过下面口诀来提前规避高复杂度操作。

* 单元素操作是基础；
* 范围操作非常耗时；
* 统计操作通常高效；
* 例外情况只有几个。

1. 单元素操作，是指每一种集合类型对单个数据实现的增删改查操作。例如，Hash类型的
HGET/HSET/HDEL，Set类型的SADD/SREM等。HSET/HGET/HDEL是对哈希表做操作，所以它们的复杂度是O(1)
Set类型用哈希表作为底层数据结构时，它的SADD/SREM/SRANDMEMBER复杂度也是O(1)。

    * 集合类型支持同时对多个元素进行增删改查，例如Hash类型的HMGET和HMSET，Set类型的SADD
也支持同时增加多个元素。此时，这些操作的复杂度，就是由单个元素操作复杂度和元素个数决定的。
    * 范围操作，是指集合类型中的遍历操作，可以返回集合中的所有数据。比如Hash类型的HGETALL和Set类型的SMEMBERS，
或者返回一个范围内的部分数据，比如List类型的LRANGE和Zset类型的ZRANGE。这类操作的复杂度是O(N)，比较耗时。
    * 统计操作，是指集合类型对集合中所有元素个数的记录。例如LLEN和SCARD，这些操作复杂度只有O(1)，因为当
    集合类型采用压缩列表、双向链表、整数数组这些数据结构时，有专门记录元素的个数统计。
    * 例外情况，是指某些数据结构的特殊记录，例如压缩列表和双向链表都会记录表头和表尾的偏移量。
    对于List类型的LPOP/RPOP/LPUSH/RPUSH这四个操作，它们是在列表的头尾增删元素，就可以通过偏移量直接定位，所以复杂度也只有O(1)
    
* 整数数组和压缩列表在查找时间复杂度方面没有很大的优势，为什么Redis把它们作为底层数据结构
    1. 内存利用率，数组和压缩列表都是非常紧凑的数据结构，它比链表占用的内存要更少。Redis
    是内存数据库，大量数据存到内存，需要做到尽可能的优化，提高内存的利用率
    2. 数组对CPU高速缓存支持友好，当数据元素超过阈值，会转为hash和跳表，保证查询效率



















